{"version":3,"names":["ruleComposer","require","eslint","rule","Linter","getRules","get","isFinalStatementInBlockStatement","node","parent","test","type","body","length","isInDoStatement","isOptionalCallExpression","expression","module","exports","filterReports","problem"],"sources":["../../src/rules/no-unused-expressions.cjs"],"sourcesContent":["const ruleComposer = require(\"eslint-rule-composer\");\nconst eslint = require(\"eslint\");\n\nconst rule = new eslint.Linter().getRules().get(\"no-unused-expressions\");\n\n/**\n * @param {ASTNode} node - any node\n * @returns {boolean} whether the given node is either an IfStatement or an\n *   ExpressionStatement and is the last node in the body of a BlockStatement\n */\nfunction isFinalStatementInBlockStatement(node) {\n  const parent = node.parent;\n  return (\n    /^(?:If|Expression)Statement$/.test(node.type) &&\n    parent.type === \"BlockStatement\" &&\n    parent.body[parent.body.length - 1] === node\n  );\n}\n\n/**\n * @param {ASTNode} node - any node\n * @returns {boolean} whether the given node represents an unbroken chain of\n *   tail ExpressionStatements and IfStatements within a DoExpression\n * https://github.com/tc39/proposal-do-expressions\n */\nfunction isInDoStatement(node) {\n  if (!node) return false;\n\n  if (node.type === \"DoExpression\") return true;\n\n  // this is an `else if`\n  if (\n    node.type === \"IfStatement\" &&\n    node.parent &&\n    node.parent.type === \"IfStatement\"\n  ) {\n    return isInDoStatement(node.parent);\n  }\n\n  if (isFinalStatementInBlockStatement(node)) {\n    return isInDoStatement(node.parent.parent);\n  }\n\n  return false;\n}\n\n/**\n * @param {ASTNode} node - any node\n * @returns {boolean} whether the given node is an optional call expression,\n * https://github.com/tc39/proposal-optional-chaining\n */\nfunction isOptionalCallExpression(node) {\n  return (\n    !!node &&\n    node.type === \"ExpressionStatement\" &&\n    node.expression.type === \"ChainExpression\" &&\n    node.expression.expression.type === \"CallExpression\"\n  );\n}\n\nmodule.exports = ruleComposer.filterReports(\n  rule,\n  problem =>\n    !isInDoStatement(problem.node) && !isOptionalCallExpression(problem.node),\n);\n"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAAC,sBAAD,CAA5B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AAEA,MAAME,IAAI,GAAG,IAAID,MAAM,CAACE,MAAX,GAAoBC,QAApB,GAA+BC,GAA/B,CAAmC,uBAAnC,CAAb;;AAOA,SAASC,gCAAT,CAA0CC,IAA1C,EAAgD;EAC9C,MAAMC,MAAM,GAAGD,IAAI,CAACC,MAApB;EACA,OACE,+BAA+BC,IAA/B,CAAoCF,IAAI,CAACG,IAAzC,KACAF,MAAM,CAACE,IAAP,KAAgB,gBADhB,IAEAF,MAAM,CAACG,IAAP,CAAYH,MAAM,CAACG,IAAP,CAAYC,MAAZ,GAAqB,CAAjC,MAAwCL,IAH1C;AAKD;;AAQD,SAASM,eAAT,CAAyBN,IAAzB,EAA+B;EAC7B,IAAI,CAACA,IAAL,EAAW,OAAO,KAAP;EAEX,IAAIA,IAAI,CAACG,IAAL,KAAc,cAAlB,EAAkC,OAAO,IAAP;;EAGlC,IACEH,IAAI,CAACG,IAAL,KAAc,aAAd,IACAH,IAAI,CAACC,MADL,IAEAD,IAAI,CAACC,MAAL,CAAYE,IAAZ,KAAqB,aAHvB,EAIE;IACA,OAAOG,eAAe,CAACN,IAAI,CAACC,MAAN,CAAtB;EACD;;EAED,IAAIF,gCAAgC,CAACC,IAAD,CAApC,EAA4C;IAC1C,OAAOM,eAAe,CAACN,IAAI,CAACC,MAAL,CAAYA,MAAb,CAAtB;EACD;;EAED,OAAO,KAAP;AACD;;AAOD,SAASM,wBAAT,CAAkCP,IAAlC,EAAwC;EACtC,OACE,CAAC,CAACA,IAAF,IACAA,IAAI,CAACG,IAAL,KAAc,qBADd,IAEAH,IAAI,CAACQ,UAAL,CAAgBL,IAAhB,KAAyB,iBAFzB,IAGAH,IAAI,CAACQ,UAAL,CAAgBA,UAAhB,CAA2BL,IAA3B,KAAoC,gBAJtC;AAMD;;AAEDM,MAAM,CAACC,OAAP,GAAiBlB,YAAY,CAACmB,aAAb,CACfhB,IADe,EAEfiB,OAAO,IACL,CAACN,eAAe,CAACM,OAAO,CAACZ,IAAT,CAAhB,IAAkC,CAACO,wBAAwB,CAACK,OAAO,CAACZ,IAAT,CAH9C,CAAjB"}