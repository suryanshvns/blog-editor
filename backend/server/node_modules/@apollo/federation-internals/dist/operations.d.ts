import { DocumentNode, FieldNode, FragmentDefinitionNode, SelectionNode, SelectionSetNode } from "graphql";
import { Directive, DirectiveTargetElement, FieldDefinition, InterfaceType, ObjectType, Schema, SchemaRootKind, Variables, VariableDefinitions, CompositeType, DeferDirectiveArgs, Variable } from "./definitions";
import { SetMultiMap } from "./utils";
declare abstract class AbstractOperationElement<T extends AbstractOperationElement<T>> extends DirectiveTargetElement<T> {
    private readonly variablesInElement;
    private attachements?;
    constructor(schema: Schema, variablesInElement: Variables);
    variables(): Variables;
    abstract updateForAddingTo(selection: SelectionSet): T;
    addAttachement(key: string, value: string): void;
    getAttachement(key: string): string | undefined;
    protected copyAttachementsTo(elt: AbstractOperationElement<any>): void;
}
export declare class Field<TArgs extends {
    [key: string]: any;
} = {
    [key: string]: any;
}> extends AbstractOperationElement<Field<TArgs>> {
    readonly definition: FieldDefinition<CompositeType>;
    readonly args: TArgs;
    readonly variableDefinitions: VariableDefinitions;
    readonly alias?: string | undefined;
    readonly kind: "Field";
    constructor(definition: FieldDefinition<CompositeType>, args?: TArgs, variableDefinitions?: VariableDefinitions, alias?: string | undefined);
    get name(): string;
    responseName(): string;
    get parentType(): CompositeType;
    withUpdatedDefinition(newDefinition: FieldDefinition<any>): Field<TArgs>;
    appliesTo(type: ObjectType | InterfaceType): boolean;
    selects(definition: FieldDefinition<any>, assumeValid?: boolean): boolean;
    validate(): void;
    updateForAddingTo(selectionSet: SelectionSet): Field<TArgs>;
    hasDefer(): boolean;
    deferDirectiveArgs(): undefined;
    withoutDefer(): Field<TArgs>;
    equals(that: OperationElement): boolean;
    toString(): string;
}
export declare class FragmentElement extends AbstractOperationElement<FragmentElement> {
    private readonly sourceType;
    readonly kind: "FragmentElement";
    readonly typeCondition?: CompositeType;
    constructor(sourceType: CompositeType, typeCondition?: string | CompositeType);
    get parentType(): CompositeType;
    castedType(): CompositeType;
    withUpdatedSourceType(newSourceType: CompositeType): FragmentElement;
    updateForAddingTo(selectionSet: SelectionSet): FragmentElement;
    hasDefer(): boolean;
    hasStream(): boolean;
    deferDirectiveArgs(): DeferDirectiveArgs | undefined;
    withoutDefer(): FragmentElement | undefined;
    withNormalizedDefer(normalizer: DeferNormalizer): FragmentElement | undefined;
    equals(that: OperationElement): boolean;
    toString(): string;
}
export declare type OperationElement = Field<any> | FragmentElement;
export declare type OperationPath = OperationElement[];
export declare function operationPathToStringPath(path: OperationPath): string[];
export declare function sameOperationPaths(p1: OperationPath, p2: OperationPath): boolean;
export declare function conditionalDirectivesInOperationPath(path: OperationPath): Directive<any, any>[];
export declare function concatOperationPaths(head: OperationPath, tail: OperationPath): OperationPath;
export declare type RootOperationPath = {
    rootKind: SchemaRootKind;
    path: OperationPath;
};
export declare class Operation {
    readonly rootKind: SchemaRootKind;
    readonly selectionSet: SelectionSet;
    readonly variableDefinitions: VariableDefinitions;
    readonly name?: string | undefined;
    constructor(rootKind: SchemaRootKind, selectionSet: SelectionSet, variableDefinitions: VariableDefinitions, name?: string | undefined);
    optimize(fragments?: NamedFragments, minUsagesToOptimize?: number): Operation;
    expandAllFragments(): Operation;
    withoutDefer(labelsToRemove?: Set<string>): Operation;
    withNormalizedDefer(): {
        operation: Operation;
        hasDefers: boolean;
        assignedDeferLabels: Set<string>;
        deferConditions: SetMultiMap<string, string>;
    };
    toString(expandFragments?: boolean, prettyPrint?: boolean): string;
}
export declare function selectionSetOf(parentType: CompositeType, selection: Selection): SelectionSet;
export declare class NamedFragmentDefinition extends DirectiveTargetElement<NamedFragmentDefinition> {
    readonly name: string;
    readonly typeCondition: CompositeType;
    readonly selectionSet: SelectionSet;
    constructor(schema: Schema, name: string, typeCondition: CompositeType, selectionSet: SelectionSet);
    withUpdatedSelectionSet(newSelectionSet: SelectionSet): NamedFragmentDefinition;
    variables(): Variables;
    collectUsedFragmentNames(collector: Map<string, number>): void;
    toFragmentDefinitionNode(): FragmentDefinitionNode;
    canApplyAtType(type: CompositeType): boolean;
    private validForSchema;
    toString(indent?: string): string;
}
export declare class NamedFragments {
    private readonly fragments;
    isEmpty(): boolean;
    variables(): Variables;
    names(): readonly string[];
    add(fragment: NamedFragmentDefinition): void;
    addIfNotExist(fragment: NamedFragmentDefinition): void;
    maybeApplyingAtType(type: CompositeType): NamedFragmentDefinition[];
    without(names: string[]): NamedFragments;
    get(name: string): NamedFragmentDefinition | undefined;
    has(name: string): boolean;
    definitions(): readonly NamedFragmentDefinition[];
    validate(): void;
    toFragmentDefinitionNodes(): FragmentDefinitionNode[];
    toString(indent?: string): string;
}
declare abstract class Freezable<T> {
    private _isFrozen;
    protected abstract us(): T;
    freeze(): T;
    protected abstract freezeInternals(): void;
    isFrozen(): boolean;
    cloneIfFrozen(): T;
    abstract clone(): T;
}
declare class DeferNormalizer {
    private index;
    readonly assignedLabels: Set<string>;
    readonly deferConditions: SetMultiMap<string, string>;
    private readonly usedLabels;
    init(selectionSet: SelectionSet): {
        hasDefers: boolean;
        hasNonLabelledOrConditionalDefers: boolean;
    };
    private nextLabel;
    newLabel(): string;
    registerCondition(label: string, condition: Variable): void;
}
export declare class SelectionSet extends Freezable<SelectionSet> {
    readonly parentType: CompositeType;
    readonly fragments?: NamedFragments | undefined;
    private readonly _selections;
    private _selectionCount;
    private _cachedSelections?;
    constructor(parentType: CompositeType, fragments?: NamedFragments | undefined);
    protected us(): SelectionSet;
    selections(reversedOrder?: boolean): readonly Selection[];
    usedVariables(): Variables;
    collectUsedFragmentNames(collector: Map<string, number>): void;
    optimize(fragments?: NamedFragments): SelectionSet;
    expandFragments(names?: string[], updateSelectionSetFragments?: boolean): SelectionSet;
    private lazyMap;
    withoutDefer(labelsToRemove?: Set<string>): SelectionSet;
    withNormalizedDefer(normalizer: DeferNormalizer): SelectionSet;
    filter(predicate: (selection: Selection) => boolean): SelectionSet;
    withoutEmptyBranches(): SelectionSet | undefined;
    protected freezeInternals(): void;
    mergeIn(selectionSet: SelectionSet): void;
    addAll(selections: readonly Selection[]): SelectionSet;
    add(selection: Selection): Selection;
    addPath(path: OperationPath, onPathEnd?: (finalSelectionSet: SelectionSet | undefined) => void): void;
    addSelectionSetNode(node: SelectionSetNode | undefined, variableDefinitions: VariableDefinitions, fieldAccessor?: (type: CompositeType, fieldName: string) => FieldDefinition<any> | undefined): void;
    addSelectionNode(node: SelectionNode, variableDefinitions: VariableDefinitions, fieldAccessor?: (type: CompositeType, fieldName: string) => FieldDefinition<any> | undefined): void;
    private nodeToSelection;
    equals(that: SelectionSet): boolean;
    contains(that: SelectionSet): boolean;
    validate(): void;
    isEmpty(): boolean;
    toSelectionSetNode(): SelectionSetNode;
    private selectionsInPrintOrder;
    toOperationPaths(): OperationPath[];
    private toOperationPathsInternal;
    forEachElement(callback: (elt: OperationElement) => void): void;
    clone(): SelectionSet;
    toOperationString(rootKind: SchemaRootKind, variableDefinitions: VariableDefinitions, operationName?: string, expandFragments?: boolean, prettyPrint?: boolean): string;
    toString(expandFragments?: boolean, includeExternalBrackets?: boolean, indent?: string): string;
}
export declare function allFieldDefinitionsInSelectionSet(selection: SelectionSet): FieldDefinition<CompositeType>[];
export declare function selectionSetOfElement(element: OperationElement, subSelection?: SelectionSet): SelectionSet;
export declare function selectionOfElement(element: OperationElement, subSelection?: SelectionSet): Selection;
export declare type Selection = FieldSelection | FragmentSelection;
export declare class FieldSelection extends Freezable<FieldSelection> {
    readonly field: Field<any>;
    readonly kind: "FieldSelection";
    readonly selectionSet?: SelectionSet;
    constructor(field: Field<any>, initialSelectionSet?: SelectionSet);
    protected us(): FieldSelection;
    key(): string;
    element(): Field<any>;
    usedVariables(): Variables;
    collectUsedFragmentNames(collector: Map<string, number>): void;
    optimize(fragments: NamedFragments): Selection;
    filter(predicate: (selection: Selection) => boolean): FieldSelection | undefined;
    protected freezeInternals(): void;
    expandFragments(names?: string[], updateSelectionSetFragments?: boolean): FieldSelection;
    private fieldArgumentsToAST;
    validate(): void;
    updateForAddingTo(selectionSet: SelectionSet): FieldSelection;
    toSelectionNode(): FieldNode;
    withUpdatedSubSelection(newSubSelection: SelectionSet | undefined): FieldSelection;
    equals(that: Selection): boolean;
    contains(that: Selection): boolean;
    namedFragments(): NamedFragments | undefined;
    withoutDefer(labelsToRemove?: Set<string>): FieldSelection;
    withNormalizedDefer(normalizer: DeferNormalizer): FieldSelection;
    clone(): FieldSelection;
    toString(expandFragments?: boolean, indent?: string): string;
}
export declare abstract class FragmentSelection extends Freezable<FragmentSelection> {
    readonly kind: "FragmentSelection";
    abstract key(): string;
    abstract element(): FragmentElement;
    abstract get selectionSet(): SelectionSet;
    abstract collectUsedFragmentNames(collector: Map<string, number>): void;
    abstract namedFragments(): NamedFragments | undefined;
    abstract optimize(fragments: NamedFragments): FragmentSelection;
    abstract expandFragments(names?: string[]): Selection | readonly Selection[];
    abstract toSelectionNode(): SelectionNode;
    abstract validate(): void;
    abstract withoutDefer(labelsToRemove?: Set<string>): FragmentSelection | SelectionSet;
    abstract withNormalizedDefer(normalizer: DeferNormalizer): FragmentSelection | SelectionSet;
    abstract updateForAddingTo(selectionSet: SelectionSet): FragmentSelection;
    abstract withUpdatedSubSelection(newSubSelection: SelectionSet | undefined): FragmentSelection;
    protected us(): FragmentSelection;
    protected validateDeferAndStream(): void;
    usedVariables(): Variables;
    filter(predicate: (selection: Selection) => boolean): FragmentSelection | undefined;
    protected freezeInternals(): void;
    equals(that: Selection): boolean;
    contains(that: Selection): boolean;
    clone(): FragmentSelection;
}
export declare function operationFromDocument(schema: Schema, document: DocumentNode, options?: {
    operationName?: string;
    validate?: boolean;
}): Operation;
export declare function parseOperation(schema: Schema, operation: string, options?: {
    operationName?: string;
    validate?: boolean;
}): Operation;
export declare function parseSelectionSet({ parentType, source, variableDefinitions, fragments, fieldAccessor, validate, }: {
    parentType: CompositeType;
    source: string | SelectionSetNode;
    variableDefinitions?: VariableDefinitions;
    fragments?: NamedFragments;
    fieldAccessor?: (type: CompositeType, fieldName: string) => (FieldDefinition<any> | undefined);
    validate?: boolean;
}): SelectionSet;
export declare function operationToDocument(operation: Operation): DocumentNode;
export {};
//# sourceMappingURL=operations.d.ts.map